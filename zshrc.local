#!/bin/env zsh


if [ -e /data/data/com.termux/files ];then
		R="/data/data/com.termux/files/usr"
		if [ ! -e $R/usr ];then
				ln -s . $R/usr
		fi
		if [ ! -e $R/usr/bin/tput ];then
			apt-get -y install ncurses-utils
		fi
else
		R=""
fi

setopt no_beep

FPATH="$R/usr/share/zsh/`zsh --version|awk '{print $2}'`/functions:$FPATH"

export LC_ALL="en_US.UTF-8"
export LANG="en_US.UTF-8"

if [ -x $R/usr/bin/go ];then
	export GOPATH=$(go env GOPATH)
	export PATH=$PATH:$GOPATH/bin
fi

if [ -d $R/usr/share/bashlib_y ];then
	export PATH=$R/usr/share/bashlib_y:$PATH
fi

## Completion configuration
#
fpath=(${HOME}/.zsh/functions/Completion ${fpath})
autoload -U compinit
compinit -u



mkdir -p $HOME/.tmp/Yk/zsh/zsh.local

eval $(zsh_rb)
# users generic .zshrc file for zsh(1)

# System wide functions and aliases
# Environment stuff goes in /etc/profile

# By default, we want this to get set.
# Even for non-interactive, non-login shells.
if [ $UID -gt 99 ] && [ "`id -gn`" = "`id -un`" ]; then
    umask 002
else
    umask 022
fi

# are we an interactive shell?
## Default shell configuration
#
# set prompt
#
autoload colors
colors

case ${UID} in
0)
	prompt_symbol="#"
	prompt_symbol_with_color="%{${fg[red]}%}#%{${reset_color}%}"
	;;
*)
	prompt_symbol="$"
	prompt_symbol_with_color="%{${fg[green]}%}\$%{${reset_color}%}"
esac

def_ruby '
	def __first_cmd c = nil
		if !c
			"__nocmd__"
		else
			data = c.strip
			arr = data.split
			progList = %W{vi vim ruby perl python supervise sv service sudo sh bash zsh rpm rpmbuild}
			cmdl = []
			arr.each do |e|
				next if progList.include? File.basename(e)
				next if e =~ /^\-/
				cmdl.push File.basename(e)
			end
			if data =~ /^(scr|\/usr\/bin\/scr|resu|resudo)(\s|$)/
				"__nocmd__"
			else
				cmdl.join(" ")
			end
		end
	end
'

if [ "$__shell_rnd__" = "" ];then
	__shell_rnd__=$(( $RANDOM./1<<15 ))
fi


def_ruby '
	def __clear_prev__ tmp
		require "Yk/path_aux"
		["cmd", "idle", "cmd-before"].each do |e|
			"$HOME/.tmp/Yk/zsh/zsh.local/#{e}.*".glob.each do |f|
				if f =~ /#{Regexp.escape e}.(\d+)/
					if !"/proc/#{tmp.to_i}".exist?
						f.unlink
					end
				end
			end
		end
	end
'
__clear_prev__ $$

#def_ruby '
#'

. $HOME/.zsh_bindkey

autoload history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
autoload -Uz bracketed-paste-magic
zle -N bracketed-paste bracketed-paste-magic

## Command history configuration
#
HISTFILE=${HOME}/.zsh_history
HISTSIZE=50000
SAVEHIST=50000

setopt hist_ignore_dups     # ignore duplication command history list
setopt share_history        # share command history data

def_ruby '
    def hist_set_cd hx, home, pwd
        d = nil
        f = "#{home}/.zsh_history_pwd.d/#{hx}"
        if File.exist? f
            d = IO.read(f).lines[-1].strip
        end
		hist_set_cd_direct d, home, pwd
    end
	def hist_set_cd_direct d, home, pwd
		print "\x1b7"
		STDOUT.flush
		system "tput cup 0 0"
	    system "tput hpa 999"
		print "\x1b[35m"
		STDOUT.flush
		begin
	        if d && !(d = d.strip).empty? && d != pwd && File.directory?(d)
			    prev_sz = hist_cmd.size # IO.read(mf).to_i rescue 0
			    if prev_sz > d.size
		    	    print "\x1b[#{prev_sz - 1}D"
	    	    	print " " * (prev_sz - d.size)
			    else
			        print "\x1b[#{d.size - 1}D"
			    end
    			print d
				@hist_cmd = d
			else
		        prev_sz = hist_cmd.size #IO.read(mf).to_i rescue 0
	    	    if prev_sz != 0
	        	    print "\x1b[#{prev_sz - 1}D"
		            print " " * prev_sz
				end
				@hist_cmd = ""
			end
		ensure
			print "\x1b[0m\x1b8"
			STDOUT.flush
		end
	end
	def hist_cmd
		@hist_cmd || ""
	end
	def clear_hist_cd
		if @hist_cmd && @hist_cmd != ""
			ret = @hist_cmd.clone
			print "\x1b7"
			system "tput cup 0 0"
			system "tput hpa 999"
			ds = @hist_cmd.size # IO.read(mf).to_i rescue 0
			print "\x1b[#{ds - 1}D\x1b[35m"
			print " " * (ds)
			STDOUT.flush
			print "\x1b[0m\x1b8"
			STDOUT.flush
			@hist_cmd = ""
			ret
		else
			""
		end
	end
'

__one_arg(){
	echo -n $1
}


__cur_hist(){
	__one_arg `history -1`
}

mkdir -p "$HOME/.tmp/Yk/zsh/zsh.local"

zstyle ':completion:*:default' menu select=2
preexec() {
	clear_hist_cd
	D_HISTNO=
	if [ "$ST_hist" != "1" ]; then
		if [ -n "$clear_hist_cd" ]; then
			if [ -z "$not_cd_hist_cd" ]; then
				cd $clear_hist_cd
			fi
		fi
		#mkdir -p ~/.zsh_history_pwd.d
		#local histno=$((`__cur_hist` + 1))
		#echo $PWD > ~/.zsh_history_pwd.d/$histno
		#mkdir -p ~/.zsh_history_raw.d
		#echo $BUFFER > ~/.zsh_history_raw.d/$histno
	fi
	local cmd
	__first_cmd $1
	cmd=$__first_cmd
	if [ "$cmd" != "__nocmd__" ]; then
		case $TERM in
		xterm*)
			echo -ne "\033]0;$cmd (${HOST%%.*}/`date +%H:%M:%S`)"; echo -ne "\007"
		    ;;
		screen)
			echo -ne "\033_$cmd (${HOST%%.*}/`date +%H:%M:%S`)"; echo -ne "\033\\"
		    ;;
		esac
		if [ -e $HOME/.tmp/Yk/zsh/zsh.local/cmd.$$.$__shell_rnd__ ];then
			mv -f "$HOME/.tmp/Yk/zsh/zsh.local/cmd.$$.$__shell_rnd__" "$HOME/.tmp/Yk/zsh/zsh.local/cmd-before.$$.$__shell_rnd__"
		fi
		echo -ne $1 > "$HOME/.tmp/Yk/zsh/zsh.local/cmd.$$.$__shell_rnd__"
		rm -f "$HOME/.tmp/Yk/zsh/zsh.local/idle.$$.$__shell_rnd__"
	fi
}
precmd() {
	echo -ne > "$HOME/.tmp/Yk/zsh/zsh.local/idle.$$.$__shell_rnd__"
}
zshexit(){
	rm -f "$HOME/.tmp/Yk/zsh/zsh.local/idle.$$.$__shell_rnd__"
	rm -f "$HOME/.tmp/Yk/zsh/zsh.local/cmd.$$.$__shell_rnd__"
	rm -f "$HOME/.tmp/Yk/zsh/zsh.local/cmd-before.$$.$__shell_rnd__"
}
ST_hist=1 preexec
ST_hist=0

# auto change directory
#
setopt auto_cd

# auto directory pushd that you can get dirs list by cd -[tab]
#
setopt auto_pushd

# command correct edition before each completion attempt
#
setopt correct

# compacked complete list display
#
setopt list_packed

# no remove postfix slash of command line
#
setopt noautoremoveslash

# no beep sound when complete list displayed
#
setopt nolistbeep

enable_bracketed_mode() {
    printf "\e[?2004h"
}

disable_bracketed_mode() {
    printf "\e[?2004l"
}
zle -N enable_bracketed_mode
zle -N disable_bracketed_mode

echo_n(){
	echo -n $@
}

zle -N none echo_n


## Keybind configuration
#
# emacs like keybind (e.x. Ctrl-a gets to line head and Ctrl-e gets
#   to end) and something additions
#
bindkey -e
case "${TERM}" in
xterm*)
	bindkey "\e[200~" disable_bracketed_mode
	bindkey "\e[201~" none
	bindkey "\e[H" beginning-of-line # Home gets to line head
	bindkey "\e[F" end-of-line # End gets to line end
	bindkey "^[[1~" beginning-of-line # Home gets to line head
	bindkey "^[[4~" end-of-line # End gets to line end
	;;
gnome*)
	bindkey "\eOH" beginning-of-line # Home gets to line head
    bindkey "\eOF" end-of-line # End gets to line end
	bindkey "^[[1~" beginning-of-line # Home gets to line head
	bindkey "^[[4~" end-of-line # End gets to line end
	;;
*)
	bindkey "^[[1~" beginning-of-line # Home gets to line head
	bindkey "^[[4~" end-of-line # End gets to line end
	;;
esac


if [ "`id -u`" = 0 ];then
	__sudo(){
		$@
	}
else
	if [ -z "$R" ];then
		ruby<<-END
			require 'pty'
			require 'etc'

			begin
				userName = Etc.getpwuid(Process.uid).name
			rescue ArgumentError
				exit 1
			end

			testStr = Random.rand(100000000).to_s
			PTY.spawn "sudo echo #{testStr}" do |r, w, pid|
				begin
					response = r.readpartial 2048
					case response
					when /^\[sudo\] password for #{Regexp.escape userName}:/
						Process.kill :INT, pid
						exit 0
					when /#{testStr}/
						exit 0
					else
						print response.ln
						exit 1
					end
				rescue EOFError
					exit 1
				end
			end
		END
		SUDO_ABLE=$?
		if [ "$SUDO_ABLE" = "0" ];then
			__sudo(){
				/usr/bin/sudo $@
			}
		else
			__sudo(){
				local ARGS="\"`declare -p @`\""
				ARGS="${ARGS#*'=('}"
				ARGS="${ARGS%')'}"
				/bin/su -c "$ARGS"
			}
		fi
	else
		if [ -e $R/usr/bin/sudo ];then
			__sudo(){
				$R/usr/bin/sudo $@
			}
		else
			__sudo(){
				echo "Error: missing sudo" >&2
				return 255
			}
		fi
	fi
fi


su(){
	if [ -z "$R" ]; then
	    if [ "$#" = 0 ]; then
	        if [ "$SUDO_ABLE" = "0" ]; then
	            __sudo $SHELL
	        else
	        	su
	        fi
	    else
	        su $@
	    fi
	else
		if [ "$#" = 0 -a -e /sbin/su ];then
			tsu
		else
			/sbin/su $@
		fi
	fi
}

resu() {
	su -c "if [ -e $HOME/.tmp/Yk/zsh/zsh.local/cmd.$$.$__shell_rnd__ ]; then ( zsh -c 'cat $HOME/.tmp/Yk/zsh/zsh.local/cmd.$$.$__shell_rnd__;echo' >> ~/.zsh_history;zsh -l $HOME/.tmp/Yk/zsh/zsh.local/cmd.$$.$__shell_rnd__ ); fi;exec zsh -l"
}
resudo() {
	if [ -e $HOME/.tmp/Yk/zsh/zsh.local/cmd.$$.$__shell_rnd__ ]; then
		sudo `cat $HOME/.tmp/Yk/zsh/zsh.local/cmd.$$.$__shell_rnd__`
	fi
}

touch $HOME/.zsh_bindkey
addline --silent $HOME/.zsh_bindkey '
#bindkey settings

bindkey "\e[H" beginning-of-line # Home gets to line head
bindkey "\e[F" end-of-line # End gets to line end
bindkey "\eOH" beginning-of-line # Home gets to line head
bindkey "\eOF" end-of-line # End gets to line end
bindkey "^[[1~" beginning-of-line # Home gets to line head
bindkey "^[[4~" end-of-line # End gets to line end
bindkey "^[[3~" delete-char # Del
bindkey "^[[5~" beginning-of-history
bindkey "^[[6~" end-of-history
bindkey "^[[5;2~" history-beginning-search-backward
bindkey "^[[6;2~" history-beginning-search-forward
bindkey "^[[1;2A" history-beginning-search-backward
bindkey "^[[1;2B" history-beginning-search-forward
bindkey "^[OA"  up-line-or-history
bindkey "^[OB"  down-line-or-history
bindkey "^[[A"  up-line-or-history
bindkey "^[[B"  down-line-or-history

#bindkey -s "^[s" "^[[A^[[H^[[1~sudo \n" #for sudo
bindkey -s "^[s" "resudo\n" #for sudo
bindkey -s "^[S" "resu\n" #for su

# historical backward/forward search with linehead string binded to ^P/^N
#
bindkey "^p" history-beginning-search-backward-end
bindkey "^n" history-beginning-search-forward-end
bindkey "\\ep" history-beginning-search-backward-end
bindkey "\\en" history-beginning-search-forward-end

bindkey "^[[1;5B" dir-history-forward
bindkey "^[[1;5A" dir-history-back

# reverse menu completion binded to Shift-Tab
#
bindkey "\e[Z" reverse-menu-complete

bindkey "^Z" undo
bindkey "^Y" redo
bindkey "\\xc2\\x9a" redo
'

. $HOME/.zsh_bindkey

typeset -g -A HIST_CMD_BUFF_MOD
typeset -g -A HIST_CMD_IS_LOADED
typeset -g -A HIST_CMD_BUFF_ORG
typeset -g -A HIST_DIR
typeset -g -A FILE_IDS
typeset -g -A FILE_CONTENT

PROG_NAME="$0"


if [ -n "$DEBUG" ];then
	dbv(){
		local ft="${funcfiletrace[1]}"
		local lno=${ft##*:}
		local file=${ft%:*}
		local id
		local ln
		local lns
		if [ -z "${FILE_IDS[$file]}" ];then
			id=$RANDOM$RANDOM$RANDOM
			FILE_IDS[$file]=$id
			while IFS= read -r ln; do
				eval "FILE_CONTENT_$id+=(\"\$ln\")"
			done < $file
		else
			id=${FILE_IDS[$file]}
		fi
		eval "ln=\"\${FILE_CONTENT_$id""[$lno]}\""
		ln="${ln#*dbv}"
		mkdir -p ~/.tmp/log/zsh_dbv
		echo "`date +"%y-%m-%d %H:%M:%S.%N"` $PROG_NAME""[$$] $file:$lno `trim_spaces ln` = $@" >> ~/.tmp/log/zsh_dbv/${PROG_NAME##*/}.log
	}
else
	dbv(){ }
fi

x-history-hook(){
	D_HISTNO=
	local histno=$HISTNO
	#if -a ! -s ~/.zsh_history_pwd.d/$HISTNO ];then
	local d_cur
	local lastno=$((`__cur_hist` + 1))
	local mode
	if [[ ${1%%-*} =~ up\|down ]];then
		mode=${1%%-*}
	elif [[ ${1##*-} =~ backward\|forward ]]; then
		mode=${1##*-}
	fi
	if [ $HISTNO = $lastno ];then
		if [ -z $HIST_CMD_IS_LOADED[$HISTNO] ];then
			HIST_DIR[$HISTNO]="$PWD"
			HIST_CMD_BUFF_MOD[$HISTNO]="$BUFFER"
			HIST_CMD_BUFF_ORG[$HISTNO]=""
			HIST_CMD_IS_LOADED[$HISTNO]=1
		fi
	fi
	local buff_prev="$BUFFER"
	local lbuff_prev="$LBUFFER"
	local cur_prev="$CURSOR"
	zle .$1
	if [ $histno != $HISTNO ];then
		dbv $?, $1, $histno, $HISTNO, ${HIST_CMD_IS_LOADED[$histno]}, $buff_prev, ${HIST_CMD_BUFF_ORG[$histno]}
		local bmod
		local org="${HIST_CMD_BUFF_ORG[$histno]}"
		if [[ $mode =~ up\|down ]]; then
			if [ -n "${HIST_CMD_IS_LOADED[$histno]}" -a "$buff_prev" != "$org" ];then
				dbv 1
				bmod="$org"
			elif [ $HISTNO = $lastno -a $mode = down -a "$buff_prev" != "" ];then
				dbv 2
				bmod=""
			elif [ $histno = $lastno -a $mode = up -a "$buff_prev" = "" ];then
				bmod="${HIST_CMD_BUFF_MOD[$histno]}"
				dbv 3 $bmod
			fi
			dbv 4
		elif [[ $mode =~ forward\|backward ]]; then
			if [ -n "${HIST_CMD_IS_LOADED[$histno]}" -a "$buff_prev" != "$org" ];then
				if [ "$lbuff_prev" = "${org:0:${#lbuff_prev}}" ];then
					dbv 1
					bmod="$org"
				fi
			fi
			dbv 4
		fi
		if [ -n "$bmod" ];then
			dbv mod
			HIST_CMD_BUFF_MOD[$histno]="$buff_prev"
			#echo $histno $HISTNO $buff_prev ${HIST_CMD_BUFF_ORG[$histno]} $BUFFER
			case $mode in
			up)
				zle .down-history
				;;
			down)
				zle .up-history
				;;
			esac
			HISTNO=$histno
			BUFFER="$bmod"
			if [[ $mode =~ up\|down ]]; then
				CURSOR=${#BUFFER}
			elif [[ $mode =~ forward\|backward ]]; then
				CURSOR=${#lbuff_prev}
			fi
			if [ "${HIST_DIR[$histno]}" != "$PWD" ];then
				cd "${HIST_DIR[$histno]}"
				zle reset-prompt
			fi
		else
			dbv ${1%%-*}
			if [ -z "${HIST_CMD_IS_LOADED[$HISTNO]}" ];then
				dbv loaded=${HIST_CMD_IS_LOADED[$HISTNO]}
				if [ -s ~/.zsh_history_pwd.d/$HISTNO ];then
					read -r d_cur < ~/.zsh_history_pwd.d/$HISTNO
				else
					dbv not load
				fi
				if [ "$d_cur" != "$PWD" ];then
					cd $d_cur
					zle reset-prompt
				fi
				HIST_DIR[$HISTNO]="$d_cur"
				local buff
				local btmp
				local hstr
				local hstr_set
				local buffer_set
				if [ -s ~/.zsh_history_raw.d/$HISTNO ];then
					while IFS= read -r btmp; do
						if [ -z "$buff" ];then
							buff="$btmp"
						else
  							buff="$buff
$btmp"
  						fi
					done < ~/.zsh_history_raw.d/$HISTNO
					if [[ "$buff" == *$'\n'* ]]; then
						dbv buffer set 1 $HISTNO buff=$buff
						BUFFER="$buff"
						buffer_set=1
					else
						hstr="`history $HISTNO $HISTNO`"
						hstr="${hstr#* }"
						hstr_set=1
						! [[ "$hstr" == *'\n'* ]]
						dbv "$hstr" contain '\\n' $?
						if ! [[ "$hstr" == *'\n'* ]]; then
							dbv setting 2 $HISTNO buff=$buff
							BUFFER="$buff"
							buffer_set=1
						else
							dbv not setting buff
						fi
					fi
				else
					dbv not read
				fi
				HIST_CMD_BUFF_MOD[$HISTNO]="$BUFFER"
				HIST_CMD_BUFF_ORG[$HISTNO]="$BUFFER"
				HIST_CMD_IS_LOADED[$HISTNO]=1
				dbv cursor $CURSOR=${#BUFFER}
			else
				if [ $histno = $lastno ];then
					HIST_CMD_BUFF_MOD[$histno]="$buff_prev"
				fi
				BUFFER="${HIST_CMD_BUFF_MOD[$HISTNO]}"
				dbv 550 $BUFFER
				if [ "${HIST_DIR[$HISTNO]}" != "$PWD" ];then
					cd "${HIST_DIR[$HISTNO]}"
					zle reset-prompt
				fi
			fi
			if [[ ${1%-*} =~ up\|down ]];then
				CURSOR=${#BUFFER}
			elif [[ ${1##*-} =~ backward\|forward ]];then
				CURSOR=$cur_prev
			fi
		fi
	elif [ $histno = $lastno ];then
		dbv $histno = $lastno
		dbv $mode $buff_prev
		if [ "$mode" = down -a "$buff_prev" != "" ];then
			HIST_CMD_BUFF_MOD[$histno]="$buff_prev"
			BUFFER=""
		fi
	fi
}

to_hook=(
	up-line-or-history
	down-line-or-history
	up-history
	down-history
	history-beginning-search-backward
	history-beginning-search-forward
	beginning-of-history
	end-of-history
)

for i in ${to_hook[@]}; do
	eval "$i(){
		x-history-hook $i
	}"
	zle -N $i
done


send-break(){
	local d_cur
	local lastno=$((`__cur_hist` + 1))
	if [ -s ~/.zsh_history_pwd.d/$lastno ];then
		read -r d_cur < ~/.zsh_history_pwd.d/$lastno
		cd $d_cur
	fi
	zle .send-break
}
zle -N send-break


function dir-history(){
	local mode=$1 # back or forward
	local skip_search=
#	echo D_HISTNO=$D_HISTNO
	if [ -z "$D_HISTNO" ];then
#		echo reset
		if [ -z "$BUFFER" ];then
			D_CLINE=1
		else
			D_CLINE=
		fi
		D_HISTNO=$HISTNO
		D_CUR=
		if [ -s "~/.zsh_history_pwd.d/$D_HISTNO" ];then
			read -r D_CUR < "~/.zsh_history_pwd.d/$D_HISTNO"
		fi
		if [ -z "$D_CUR" ];then
			D_CUR="$PWD"
		fi
		typeset -g -A D_DIR2HNO
		typeset -g -A D_HNO2DIR
		typeset -g -A D_HNO_NEXT
		typeset -g -A D_HNO_PREV
		D_DIR2HNO=("$D_CUR" "$D_HISTNO")
		D_HNO2DIR=("$D_HISTNO" "$D_CUR")
		D_HNO_BAK=()
		D_HNO_FWD=()
		if [ "$D_CUR" != "$PWD" ];then
			skip_search=1
		fi
	fi
	if [ -z "$skip_search" ];then
#		echo "D_HNO_BAK[$D_HISTNO]=${D_HNO_BAK[$D_HISTNO]}"
		[ -z "${D_HNO_BAK[$D_HISTNO]}" ]
#		echo $?
		if ( [ "$mode" = back ] && [ -z "${D_HNO_BAK[$D_HISTNO]}" ] ) || ( [ "$mode" != back ] && [ -z "${D_HNO_FWD[$D_HISTNO]}" ] );then
#			echo 2.5
#			[ "$mode" = back ] && ((D_HISTNO >= 2)) || [ "$mode" != back ] && ((D_HISTNO < HISTCMD - 1))
#			echo $?
#			[ "$mode" = back ] && ((D_HISTNO >= 2))
#			echo $?
#			[ "$mode" != back ] && ((D_HISTNO < HISTCMD - 1)) || [ "$mode" = back ] && ((D_HISTNO >= 2))
#			echo $?
#			( [ "$mode" = back ] && ((D_HISTNO >= 2)) ) || ( [ "$mode" != back ] && ((D_HISTNO < HISTCMD - 1)) )
#			echo $?
			if ( [ "$mode" = back ] && ((D_HISTNO >= 2)) ) || ( [ "$mode" != back ] && ((D_HISTNO < HISTCMD - 1)) ); then
#				echo 3
				local tmp
				local d_cur_org="$D_CUR"
				local d_histno_org="$D_HISTNO"
				if [ "$mode" = back ]; then
#					echo 4
					((--D_HISTNO))
				else
#					echo 5
					((++D_HISTNO))
				fi
				while ( [ "$mode" = back ] && ((D_HISTNO > 0)) ) || ( [ "$mode" != back ] && ((D_HISTNO < HISTCMD)) ); do
#					echo 6 "-$D_HISTNO-"
#					[ -e ~/.zsh_history_pwd.d/$D_HISTNO ]
#					echo $?
					if [ -e ~/.zsh_history_pwd.d/$D_HISTNO ];then
#						echo 7
#						echo 100
#						cat ~/.zsh_history_pwd.d/$D_HISTNO
						read -r D_CUR < ~/.zsh_history_pwd.d/$D_HISTNO
#						echo $D_CUR
						if [ -n "$D_CUR" -a "$d_cur_org" != "$D_CUR" -a -z "${D_DIR2HNO[$D_CUR]}" ];then
#							echo 8
							D_DIR2HNO[$D_CUR]="$D_HISTNO"
							D_HNO2DIR[$D_HISTNO]="$D_CUR"
							D_HNO_BAK[$d_histno_org]="$D_HISTNO"
							D_HNO_FWD[$D_HISTNO]="$d_histno_org"
							break
						fi
					fi
#					echo 9
					if [ "$mode" = back ]; then
#						echo 10
						((--D_HISTNO))
					else
						echo $D_HISTNO
						((++D_HISTNO))
					fi
				done
#				echo 12
			fi
		elif ( [ "$mode" = back ] && [ -n "${D_HNO_BAK[$D_HISTNO]}" ] ); then
#			echo 13
			D_HISTNO=${D_HNO_BAK[$D_HISTNO]}
			D_CUR=${D_HNO2DIR[$D_HISTNO]}
		elif ( [ "$mode" != back ] && [ -n "${D_HNO_FWD[$D_HISTNO]}" ] ); then
			D_HISTNO=${D_HNO_FWD[$D_HISTNO]}
			D_CUR=${D_HNO2DIR[$D_HISTNO]}
		fi
#		echo 14
	fi
#	echo 15
	if [ -z "$RESET_PROMPT" ];then
		if [ -n "$D_CLINE" ];then
	#		echo 16
			if [ "$D_CUR" = "$PWD" ];then
				BUFFER=
			elif [ "$D_CUR" = "$HOME" ];then
				BUFFER='~/'
			else
				local b
				if [ $D_CUR != "/" ];then
					local _D_CUR="$(escape_special_chars D_CUR)"
					if [ ${D_CUR:0:$((${#PWD} + 1))} = $PWD/ ]; then
						BUFFER="${_D_CUR#$PWD/}"/
					elif [ ${D_CUR:0:$((${#HOME} + 1))} = $HOME/ ]; then
						BUFFER="~""/${_D_CUR#$HOME/}"/
					else
						BUFFER="$_D_CUR"/
					fi
				else
					BUFFER=/
				fi
			fi
		fi
	#	echo 17
		hist_set_cd "$D_HISTNO" "$HOME" "$PWD"
	else
		cd "$D_CUR"
		zle reset-prompt
	fi
}

function escape_special_chars {
  eval "local var=\$$1"
  printf "%q\n" "$var"
}


dir-history-back(){
	dir-history back
}


dir-history-forward(){
	dir-history forward
}


dir-history-back-prompt-change-back(){
	RESET_PROMPT=1
	dir-history back
	RESET_PROMPT=
}


dir-history-back-prompt-change-forward(){
	RESET_PROMPT=1
	dir-history forward
	RESET_PROMPT=
}


zle -N dir-history-back dir-history-back
zle -N dir-history-forward dir-history-forward

bindkey "^[[1;5D" dir-history-back-prompt-change-back
bindkey "^[[1;5C" dir-history-back-prompt-change-forward

zle -N dir-history-back-prompt-change-back dir-history-back-prompt-change-back
zle -N dir-history-back-prompt-change-forward dir-history-back-prompt-change-forward

#zle -N history-beginning-search-backward-end-pwd history-beginning-search-backward-end-pwd
#zle -N history-beginning-search-forward-end-pwd history-beginning-search-forward-end-pwd
#zle -N up-line-or-history-hook up-line-or-history-hook
#zle -N down-line-or-history-hook down-line-or-history-hook
#zle -N up-line-or-history
#zle -N down-line-or-history
#zle -N history-beginning-search-backward
#zle -N history-beginning-search-forward


## zsh editor
#
autoload zed


## Prediction configuration
#
#autoload predict-on
#predict-off


## Alias configuration
#
# expand aliases before completing
#
setopt complete_aliases     # aliased ls needs if file/dir completions work

alias where="command -v"
alias j="jobs -l"

alias du="du -h"
alias df="df -h"

## terminal configuration
#
case "${TERM}" in
screen)
    TERM=xterm
    ;;
esac

case "${UID}" in
0)
	mode_color="%{${fg[red]}%}"
	bold_start="%B"
	bold_end="%b"
	alias rm='rm -i'
	alias cp='cp -i'
	alias mv='mv -i'
	alias vi='vim'
	;;
*)
	mode_color="%{${fg[cyan]}%}"
	;;
esac

PROMPT="${bold_start}[$mode_color%n@%m %{$fg[yellow]%}%~%{${reset_color}%}${bold_start}]${prompt_symbol_with_color}$bold_end "
RPROMPT="%{${fg[magenta]}%}%*%{${reset_color}%}"

IFS=$'\n\t '

if systemctl > /dev/null 2>&1;then
	systemctl=systemctl
fi

_w(){
	which $1 > /dev/null 2>&1
}

if [ -z "$systemctl" ];then
	_zv(){
		compadd `ls /etc/service_pool`
	}
	compdef _zv zv
else
	if _w sv && ! _w runsv; then
		_sv(){
		    compadd `systemctl list-units --type=service -all | ruby -e 'STDIN.each_line do |ln| if ln =~ /([^\s]+)\.service/; print $1 + "\n";end;end'`
		}
		compdef _sv sv
	fi
	if _w lv; then
		_lv(){
			compadd `sudo journalctl -F '_SYSTEMD_UNIT' | ruby -e 'STDIN.each_line do |ln| if ln =~ /([^\s]+)\.service/; print $1 + "\n";end;end'`
			compadd `getLVWList`
		}
		compdef _lv lv
	fi
fi


def_ruby '
	def getLVWList
		require "Yk/path_aux"
		require "Yk/debug2"
		require "set"
		ret = Set.new
		dids = Hash.new
		gList = []
		fProc = Proc.new do |e, dir|
			begin
				f = e.relative_path_from dir
				if f !~ /\.\d+$/ && f !~ /\-20\d+/ && f !~ /sa\/sa(r|)\d+/ && e != "/var/log/sa"
					ret.add f
				end
			rescue => err
				h = ENV["HOME"]
				"#{h}/.tmp/zshtest".write_a err.to_s
			end
		end
		proc = Proc.new do |d, dir|
			dir ||= d
			if d._d?
				s = d.stat
				if ! dids.key? [s.dev, s.ino]
					dids[[s.dev, s.ino]] = 1
					isLogDir = false
					if d._r?
						d.each_entry do |e|
							if (e.basename == "current" || e.basename =~ /^\@[0-9a-f]{24}\.(s|u)$/) && e.file_size != 0
								isLogDir = true
								rd = d.relative_path_from(dir)
								if rd == "."
									if d =~ /\/log$/
										ret.add d.dirname.basename
									elsif d =~ /\/log\/main$/
										ret.add d.dirname.dirname.basename
									else
										ret.add d.basename
									end
								else
									ret.add rd
								end
								break
							end
						end
						d.each_entry do |e|
							if (!isLogDir && d.basename != "log") || (!%{current lock state run ok down supervise}.include?(e.basename) && e.basename !~ /^\@[0-9a-f]{24}\.(s|u)$/)
								if e._d?
									proc[e, gList.find{_1 == e} || dir]
								elsif e._f? && e.file_size != 0 && e._r? && (((ol = e.readline rescue "\x00") !~  /^\#\!/ && ol !~ /\x00/) rescue nil)
									fProc[e, dir]
								end
							end
						end
					end
				end
			elsif d._f? && d._r?
				fProc[d, dir]
			end
		end
		r = ENV["R"]
		["#{r}/var/log", "#{r}/var/service/*/log", "#{r}/etc/service/*/log/main", "#{r}/var/log/sv", "#{r}/var/service_log"].each do |e|
			gList += e.glob
		end
		gList.inspect.ln
		gList.each do |e|
			proc[e]
		end
		require "shellwords"
		ret = Shellwords.join(ret.to_a)
		ret
	end
'

_lvw(){
	getLVWList
	compadd `echo $getLVWList`
}
compdef _lvw lvw


sudo(){
	if [ "$1" = "vi" ]; then
		shift
		__sudo vim $@
	else
		__sudo $@
	fi
}

make(){
	if [ "$1" = "install" ]; then
		shift
		__sudo make install $@
	else
		__sudo $@
	fi
}

gem(){
	if [ "$1" = "install" ]; then
		shift
		__sudo $R/usr/bin/gem install $@
	else
		$R/usr/bin/gem $@
	fi
}

if [ -e /bin/rpm ];then
	rpm(){
		ruby <<-END
			cmd = %w{$1}[0]
			cmds = %w{$*}
			if cmd[0] == ?- && cmd[1] != ?-
				if cmd =~ /[iUe]/ && !cmds.find{|e| e =~ /^[^\-].*\.src\.rpm$/}
					system *%w{/usr/bin/sudo $R/bin/rpm $*}
				else
					system *%w{/bin/rpm $*}
				end
			end
		END
	}
fi

if [ -x /usr/bin/loadkeys ];then
	jp(){
		if [ "$TTY" = "/dev/tty1" ];then
			loadkeys jp106
		else
			LANG=ja_JP.UTF-8
			LC_ALL=ja_JP.UTF-8
		fi
	}

	us(){
		if [ "$TTY" = "/dev/tty1" ];then
			loadkeys us
		else
			LANG=en_US.UTF-8
			LC_ALL=en_US.UTF-8
		fi
	}
fi

if [ -x $R/usr/bin/proz ];then
	proz(){
		$R/usr/bin/proz -k=10 "$@"
	}
fi

if [ -x $R/usr/bin/dstat ];then
	iotop(){
		$R/usr/bin/dstat --top-io-adv --top-bio-adv "$@"
	}
fi


if [ -e /mnt/c/Windows/explorer.exe ];then
	explorer(){
		/mnt/c/Windows/explorer.exe "$@"
	}
fi


ping(){
	__sudo ping "$@"
}


if [ -e /usr/bin/cygpath ]; then
	__SYSTEM=`cygpath -u ${SYSTEMROOT}`/system32
	alias ping="cocot -p CP932 $__SYSTEM/ping.exe -n 10000"
	alias arp="cocot -p CP932 $__SYSTEM/arp.exe"
	alias nslookup="cocot -p CP932 $__SYSTEM/nslookup.exe"
	alias traceroute="cocot -p CP932 $__SYSTEM/tracert.exe"
	alias route="cocot -p CP932 $__SYSTEM/route.exe"
	alias netstat="cocot -p CP932 $__SYSTEM/netstat.exe"
	alias ipconfig="cocot -p CP932 $__SYSTEM/ipconfig.exe"
	alias ifconfig="cocot -p CP932 $__SYSTEM/ipconfig.exe"
	alias cpl='/cygdrive/c/WINDOWS/explorer.exe /e,::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}'
	#alias start="$SYSTEM/CMD.exe /c start"
	alias net="cocot -p CP932 $__SYSTEM/net.exe"
	alias start=cygstart
	unset __SYSTEM
elif [ ! -e /sbin/ifconfig ]; then
	alias /sbin/ifconfig="ip a show"
fi
alias axel="axel --num-connections=10"
alias vi="vim"


fnd(){
	local r
	if [[ $RAW_CMD_LINE =~ (^|\\W)fnd\\s+([^\|\ \t\<\>]+) ]];then
		r="${match[2]}"
		if [[ ${RAW_CMD_LINE:$MEND} =~ (^|\W)fnd\s ]];then
			echo "fnd: Error: multiple fnd found in the command line" >&2
			return 255
		fi
	fi
	if [ -n "$r" ];then
		local fn="${r##*/}"
		if [ "$fn" = "$r" ]; then
			find . -name "$r"
		else
			local dn="${r%/*}"
			if [ "$dn" = "~" ];then
				dn="$HOME"
			fi
			find "$dn" -name "$fn"
		fi
	else
		echo "fnd: Error: missing argument" >&2
		return 1
	fi
}


def_ruby '
	require "shellwords"
	require "Yk/path_aux"
	def raw_cmd_line buff = nil
		if buff
			#"/tmp/raw_cmd_line.log".write_a "#{Time.now} buff=#{buff.inspect}\n"
			carr = Shellwords.split(buff)
			if carr[0] == "fnd"
				carr.shift
				dir = "."
				fname = "*"
				if carr.size >= 2
					dir = carr[0]
					fname = carr[1]
				elsif carr.size == 1
					if carr[0] !~ /^(.*)\/([^\/]*)$/
						fname = carr[0]
					else
						fname = $2
						dir = $1
						if dir == ""
							dir = "/"
						end
					end
				end
				carr.clear
				carr.push "find"
				carr.push dir
				carr.push "-name"
				carr.push fname
				Shellwords.shelljoin(carr)
			else
				carr.shift
				carr.each do |e|
					if e =~ /^[~\w_\.\/][~\w_\.\/-]*$/
						e = e.expand_path
						if e._d?
							"~/.command_arg_dirs".expand_path.write_la e.ln 
						else
							"~/.command_arg_files".expand_path.write_la e.ln
						end
					end
				end
				""
			end
		else
			""
		end
	end
'

function trim_spaces {
  local var="${(P)1}"
  var="${var#"${var%%[![:space:]]*}"}"   # 前のスペースを削除
  var="${var%"${var##*[![:space:]]}"}"   # 後のスペースを削除
  echo "$var"
}

function getFirst {
	echo "$1"
}

setopt +o nomatch

ORG_PWD="$PWD"

function __raw_cmd_line {
	local histno=$((`__cur_hist` + 1))
	dbv __raw_cmd_line $histno "$PREBUFFER$BUFFER"
	echo "$PWD" > ~/.zsh_history_pwd.d/$histno
	mkdir -p ~/.zsh_history_raw.d
	export RAW_CMD_LINE="$PREBUFFER$BUFFER"
	echo "$RAW_CMD_LINE" > ~/.zsh_history_raw.d/$histno
	local var="$(trim_spaces BUFFER)"
	var=${var%% *}
	if [ -z $var ];then
		cd $ORG_PWD
		zle accept-line
	else
		if [ "${var: -1:1}" = "/" -a -d "${var%?}" ];then
			BUFFER="${var%?}"
		fi
		HIST_CMD_BUFF_MOD=()
		HIST_CMD_IS_LOADED=()
		zle accept-line
		ORG_PWD="$PWD"
		echo $histno > ~/.zsh_history_raw.d/max
		echo $histno > ~/.zsh_history_pwd.d/max
	fi
}


trap "zle reset-prompt" USR1


zle-line-init() {
	if [ -z "$INITIAL_HISTNO" ];then
		INITIAL_HISTNO=$HISTNO
		
	fi
	dbv zle-line-init $HISTNO $histno $ORG_PWD $PWD
	if [ "$ORG_PWD" != "$PWD" ];then
		dbv resetting from $ORG_PWD to $PWD
		cd "$ORG_PWD"
		kill -s SIGUSR1 $$
	fi
}
zle -N zle-line-init

function _raw_cmd_line {
	not_cd_hist_cd=
	__raw_cmd_line
}


function _raw_cmd_line_shift {
	not_cd_hist_cd=1
	__raw_cmd_line
}


zle -N raw_cmd_line_widget _raw_cmd_line
zle -N raw_cmd_line_shift_widget _raw_cmd_line_shift

bindkey '^M' raw_cmd_line_widget
bindkey '^J' raw_cmd_line_shift_widget

if [ -f $R/etc/colorrc ]; then
    eval `dircolors $R/etc/colorrc`
fi

def_ruby '
	def sendInt proc, lag
		proc = proc.to_i
		lag = lag.to_f
		Thread.new do
			Thread.pass
			sleep lag
			Process.kill :INT, proc
		end
	end
'

hiscd(){
	
}


enable_bracketed_mode () {
        printf "\e[?2004h"
}

disable_bracketed_mode () {
        printf "\e[?2004l"
}

key(){
	showkey -a
}

